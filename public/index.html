<!DOCTYPE html>
<html>
<head>
	<title>Ping Pong Game</title>
</head>
<body>
	<canvas id="canvas" width="800" height="400"></canvas>
	<style>
		/**
			Overflow being hidden prevents the presence of a scrollbar in a resizable, fullscreen game.
		*/
		body {
			overflow: hidden;
		}
	</style>
		
	<script type="text/javascript" src="js/app.js"></script>
	<script type="text/javascript">
		// Apply a margin to the body that can be accounted for programatically.
		const BODY_MARGIN = 10;
		document.querySelector("body").style.margin = BODY_MARGIN+"px";

		/**
		 * @typedef {{id: string, x: number, y: number, width: number
		 * , height: number, color: string}} AppNode
		 * @typedef {AppNode & {traj_x: number, traj_y: number}} MovingNode
		 * */


		/** 
		 * Adjust both the canvas and the app to resize the game.
		 * @param {{height: number, width: number, clear: ()=>void}} app
		 * @param {number} width
		 * @param {number} height
		 **/
		function resize_game(app, height, width) {
			document.getElementById("canvas").height = height;
			document.getElementById("canvas").width = width;
			app.height = height; app.width = width;
			app.clear();
			// TODO: adjust app nodes accordingly.
		}
		var build_NodeUtil = ((app) => {

			/**
			 * @typedef {{x: number | undefined, y: number | undefined}} XY_Adjustment -- X & Y adjustments proposed. For ease of use, undeclared=0.
			 * @typedef {"X" | "Y" | "BOTH"} CollisionReason
			*/
			/**
			 * Will Collide? Check if the proposed changes to the node will cause a collision.
			 * @param {{height: number, width: number}} app -- We're highlighting the pieces we pull from the app.
			 * @param {AppNode} node
			 * @param {XY_Adjustment} xyadj
			 * @returns {{c: "YES", reason: CollisionReason} | {c: "NO"}}
			 * */
			function will_node_collide(node, xyadj) {
				let prop_x = node.x+(xyadj.x ?? 0), prop_y = node.y+(xyadj.y ?? 0);
				/**@type{{width: number, height: number}}*/
				let {width: app_x, height: app_y} = app;
				let x_failed = (prop_x < 0 || prop_x+node.width > app_x)
				, 	y_failed = (prop_y < 0 || prop_y+node.height > app_y);
				return (x_failed && y_failed ? {c: "YES", reason: "BOTH"} 
							: x_failed ? {c: "YES", reason: "X"} 
							: y_failed ? {c: "YES", reason: "Y"} 
							: {c: "NO"});
			}

			/**
			 * Attempt to move a node. Send back data for success or failure.
			 * @param {AppNode} node
			 * @param {XY_Adjustment} xyadj
			 * @returns {{c: "MOVED"} | {c: "STAYED", reason: CollisionReason}}
			 **/
			function move_node(node, xyadj) {
				let m_collision = will_node_collide(node, xyadj);
				if(m_collision.c == "NO") {
					node.x += (xyadj.x ?? 0);
					node.y += (xyadj.y ?? 0);
					return {c: "MOVED"};
				}else{
					return {c: "STAYED", reason: m_collision.reason};
				}
			}
		});
		/**@type{ReturnType<build_NodeUtil>}*/
		var NodeUtil;

		app.onInit = function(){

			// Call to update canvas/app to new size. Declared here to lock in app as `this` to the scope.
			// We're also only using this once elsewhere, in the below event declaration.
			let update_size_to_viewport = () => resize_game(this, window.visualViewport.height-BODY_MARGIN, window.visualViewport.width-BODY_MARGIN);
			update_size_to_viewport();
			// onInit will only be called once so declaring this event here is safe.
			window.addEventListener("resize", update_size_to_viewport);

			// I recognize that I could have created this earlier by referencing `app` directly in the global scope,
			// but here I am preparing for the possibility that I am not 'ready' until I am in an init function.
			// Same reason I capture `this` in update_size_to_viewport.
			// Ultimately, I build NodeUtil here because of the requirement to not touch app.js 
			// (and by extension, safe-assumedly, not extending the app global var itself)
			NodeUtil = build_NodeUtil(this);


			this.nodes.push({
				id : 'red-box',
				x  : 100,
				y  : 0,
				width  : 100,
				height : 100,
				color  : 'red',
				direction : 0
			});

			this.nodes.push({
				id : 'black-box',
				x  : 50,
				y  : 0,
				width  : 150,
				height : 150,
				color  : 'black'
			});
		};

		app.onUpdate = function(time){
			// Again, not touching app.js. I'd prefer that onUpdate occur
			// after initialization, not before it (app.js line 22 & 23 being swapped).
			// So this is a clunky workaround that adds another boolean check to the sensitive update function. 
			// I could fall back to global variable assumptions (easiest, but not the best for long-term if there's more work to be done in app.onInit)
			// or I could wrap app.onInit and app.onUpdate in its own init, but that would appear redundant at first glance. Consider this a TODO.
			if(NodeUtil == undefined) return;

			if(Math.cos(this.timestamp / 100) > 0){
				this.getNode('red-box').direction = -1;
			}else{
				this.getNode('red-box').direction = 1;
			}

			this.getNode('red-box').x+=this.getNode('red-box').direction;
		};
	</script>
</body>
</html>